# spring cloud学习记录

## 简介部分

### 单体架构

- 简介:单体架构对业务场景没有划分,将所有业务场景的表示层,业务逻辑层和数据访问层都放在一个工程里面,最终一起部署
- 不足:
  - 随着业务发展,代码量越来越多,代码的可读性/可维护性/可扩展性下降
  - 并发能力有限
  - 难以测试


### 微服务

#### 特点

- 微服务单元按业务来划分

开发模式从传统的职能划分变为按业务划分,也就是一个业务一个团队

- 通过HTTP通信
  - 使用RESTful API方式通信,或者通过RabbitMQ/Kafaka等轻量级消息总线通信
  - 数据格式通常为json/XML或者通过Protobuf序列化
  - 当然这种通讯方式不依赖于编程语言,即Java写的服务可以消费Go写的服务
  - 弊端就是其通信机制不可靠,虽然成功率高但是还是会有失败的时候

> 使用Protobuf进行数据序列化时,产生的数据为二进制,需要反序列化才能读懂,但是由于更为轻量,所以也十分受欢迎

- 数据库独立

服务于服务之间通过HTTP通信的话,每个服务都可以有自己的数据库. 而且可以使用不同的数据库,比如A服务使用MySQL,B服务使用MongoDB等

- 服务集中化管理

由于按照业务划分服务,服务的数量很多,所以必须集中管理服务. 像Eureka/Zookeeper等都是非常优秀的服务集中化管理框架

- 分布式架构
  - 微服务架构是分布式架构
  - 分布式系统是集群部署的
  - 分布式系统通过网络协议来通信
  - 熔断机制是为了防止"雪崩效应"

> 雪崩效应: 分布式系统中的服务通信依赖于网络,网络不好,必然会对分布式系统带来很大的影响.在分布式系统中,服务之间相互依赖,如果一个服务出现了故障或者是网络延迟,在高并发的情况下,会导致线程阻塞,在很短的时间内该服务的线程资源会被消耗殆尽,最终使得该服务不可用.由于服务的相互依赖,可能会导致整个系统的不可用,这就是"雪崩效应"

- 熔断机制

为了防止上述的雪崩效应,分布式系统采用了熔断机制. 当服务A出现故障时,请求失败次数超过设定的阈值之后,服务A就会开启熔断器(spring cloud的组件),之后服务A不进行任何的业务逻辑操作,执行快速失败,直接返回请求失败的信息.其他依赖于服务A的服务就不会因为得不到响应而线程阻塞,这时除了服务A和依赖于服务A的部分功能不可用之外,其他功能正常.

这个spring cloud的熔断组件熔断器还有一个机制,就是自我修复机制. 当服务A熔断后,经过一段时间半打开熔断器,半打开的熔断器会检查一部分请求是否正常,其他请求执行快速失败,检查的请求如果响应成功,则可以判定服务A正常了,就会关闭服务A的熔断器.反之则继续开启熔断器.

#### 优势

- 代码被拆分,服务之间边界明确,可读性和可扩展性增加,新人加入团队只需要了解他接管的服务的代码即可
- 边界明确,服务之间没有任何耦合,易横向扩展
- 服务之间通过HTTP通信,可以使用多种开发语言和技术实现
- 重写某服务的代码容易
- 测试和部署简单

#### 不足

- 复杂

微服务系统是分布式系统,构建的复杂度远远超过单体系统

- 分布式事物

分布式事物常常分为两个阶段提交,第一个阶段发起分布式事物,交给事务管理器,事务管理器通知所有节点做准备,所有节点收到指令后做相应准备并且记录日志然后返回准备结果. 第二阶段就是收集到了所有节点返回的数据之后,如果全都成功就执行提交,只要有一个失败就进行回滚

分布式事物大大降低数据库的性能,而且不可靠,所以一般情况下,尽量少用.

- 服务的划分

服务划分的粒度难控制







