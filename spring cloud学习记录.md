# spring cloud学习记录

## 简介部分

### 单体架构

- 简介:单体架构对业务场景没有划分,将所有业务场景的表示层,业务逻辑层和数据访问层都放在一个工程里面,最终一起部署
- 不足:
  - 随着业务发展,代码量越来越多,代码的可读性/可维护性/可扩展性下降
  - 并发能力有限
  - 难以测试


### 微服务

#### 特点

- 微服务单元按业务来划分

  开发模式从传统的职能划分变为按业务划分,也就是一个业务一个团队

- 通过HTTP通信
  - 使用RESTful API方式通信,或者通过RabbitMQ/Kafaka等轻量级消息总线通信
  - 数据格式通常为json/XML或者通过Protobuf序列化
  - 当然这种通讯方式不依赖于编程语言,即Java写的服务可以消费Go写的服务
  - 弊端就是其通信机制不可靠,虽然成功率高但是还是会有失败的时候

> 使用Protobuf进行数据序列化时,产生的数据为二进制,需要反序列化才能读懂,但是由于更为轻量,所以也十分受欢迎

- 数据库独立

  服务于服务之间通过HTTP通信的话,每个服务都可以有自己的数据库. 而且可以使用不同的数据库,比如A服务使用MySQL,B服务使用MongoDB等

- 服务集中化管理

  由于按照业务划分服务,服务的数量很多,所以必须集中管理服务. 像Eureka/Zookeeper等都是非常优秀的服务集中化管理框架

- 分布式架构
  - 微服务架构是分布式架构
  - 分布式系统是集群部署的
  - 分布式系统通过网络协议来通信
  - 熔断机制是为了防止"雪崩效应"

> 雪崩效应: 分布式系统中的服务通信依赖于网络,网络不好,必然会对分布式系统带来很大的影响.在分布式系统中,服务之间相互依赖,如果一个服务出现了故障或者是网络延迟,在高并发的情况下,会导致线程阻塞,在很短的时间内该服务的线程资源会被消耗殆尽,最终使得该服务不可用.由于服务的相互依赖,可能会导致整个系统的不可用,这就是"雪崩效应"

- 熔断机制

  为了防止上述的雪崩效应,分布式系统采用了熔断机制. 当服务A出现故障时,请求失败次数超过设定的阈值之后,服务A就会开启熔断器(spring cloud的组件),之后服务A不进行任何的业务逻辑操作,执行快速失败,直接返回请求失败的信息.其他依赖于服务A的服务就不会因为得不到响应而线程阻塞,这时除了服务A和依赖于服务A的部分功能不可用之外,其他功能正常.

  这个spring cloud的熔断组件熔断器还有一个机制,就是自我修复机制. 当服务A熔断后,经过一段时间半打开熔断器,半打开的熔断器会检查一部分请求是否正常,其他请求执行快速失败,检查的请求如果响应成功,则可以判定服务A正常了,就会关闭服务A的熔断器.反之则继续开启熔断器.

#### 优势

- 代码被拆分,服务之间边界明确,可读性和可扩展性增加,新人加入团队只需要了解他接管的服务的代码即可
- 边界明确,服务之间没有任何耦合,易横向扩展
- 服务之间通过HTTP通信,可以使用多种开发语言和技术实现
- 重写某服务的代码容易
- 测试和部署简单

#### 不足

- 复杂

  微服务系统是分布式系统,构建的复杂度远远超过单体系统

- 分布式事物

  分布式事物常常分为两个阶段提交,第一个阶段发起分布式事物,交给事务管理器,事务管理器通知所有节点做准备,所有节点收到指令后做相应准备并且记录日志然后返回准备结果. 第二阶段就是收集到了所有节点返回的数据之后,如果全都成功就执行提交,只要有一个失败就进行回滚

  分布式事物大大降低数据库的性能,而且不可靠,所以一般情况下,尽量少用.

- 服务的划分

  服务划分的粒度难控制


#### 设计原则

技术应该是随着业务的发展而发展的,不能盲目的使用微服务架构.



## spring cloud简介

首先我们再来讲讲微服务应该具备的功能

### 微服务应该具备的功能

微服务具有以下特点:

- 按照业务划分服务
- 微服务之间相互独立
- 通过HTTP或者消息组件通信,具有容错能力
- 相互之间不耦合,可随时增加和剔除
- 单个服务能够集群化部署,并且具有负载均衡的能力
- 整个微服务系统应该有一个完整的安全机制
- 整个微服务系统有链路追踪的能力
- 有一套完整的实时日志系统

微服务的功能重要体现在:

- 服务的注册和发现
- 服务的负载均衡
- 服务的容错
- 服务网关
- 服务配置的统一管理
- 链路追踪
- 实时日志

### 服务的注册和发现

- 服务的注册

  服务的注册是指,向服务注册中心注册一个服务实例,服务提供者将自己的服务信息(如服务名,IP地址等等)告知服务注册中心

- 服务的发现

  服务的发现是指,当服务消费者需要消费另外一个服务时,服务注册中心能够告知服务消费者它所需要消费服务的实例信息

通常情况下,一个服务既是服务消费者,也是服务提供者. 服务消费一般是通过HTTP或者消息组件.

一个服务实例注册后,需要定时的向服务注册中心发送"心跳",证明自己还处于可用状态,如果一段时间没有发送心跳,服务注册中心则会认为这个服务不可用,从服务注册列表中将其剔除,过一段时间如果心跳恢复,则又会将其加入到服务注册列表之中

### 服务的负载均衡

- 什么是负载均衡

  在微服务架构中,服务之间的相互调用一般是通过HTTP通信协议来实现的.由于网络具有不可靠性,所以为了保证服务的高可用,服务单元往往是集群化部署. 那么每个服务就可能存在多个实例,在服务消费的时候就需要做负载均衡

- 谁来做负载均衡

  服务的负载均衡最流行的一种做法是,由服务消费者来做负载均衡. 所有的服务都向服务注册中心注册,然后定时的发送心跳.同时每个服务也会定时的获取所有服务注册列表信息. 在进行服务消费的时候,消费者服务就根据自己已知的服务注册列表,通过一定的负载均衡策略(轮询,哈希等等,可由开发者配置)进行负载均衡.

服务注册中心不但需要定时接收每个服务的心跳,而且每个服务还会定期的获取服务注册列表的信息,当服务实例数量非常多的时候服务注册中心的负载时非常大的,所以,服务注册中心也需要进行集群部署.把服务注册中心集群化之后,服务注册中心之间实时同步信息,实现了高可用.

### 服务的容错

服务的容错主要是运用熔断机制,这种机制的原理在上面已经说过了,在这就不在赘述了.在这讲一下这种熔断机制除了防止系统的"雪崩",还具有服务降级的能力,如果请求的数量超过了服务的处理能力时,会将其降级,避免服务器负载过高.

### 服务网关

- 服务网关是干什么的

  在微服务系统中,API接口资源通常是由服务网关统一暴露,并且服务网关通常还有请求转发/安全验证等作用.

一般来说,在服务网关层之前需要加上负载均衡层.用户请求通过负载均衡转发到网关层,然后进行一些安全验证转发到具体的服务.

网关层具有以下重要意义:

- 将所有服务的API接口资源聚合,对外统一暴露
- 安全验证
- 监控,实时日志输出,请求记录等
- 流量监控,在流量过高情况下,对服务进行降级
- API接口从内部服务分离出来方便测试



### 服务配置的统一管理

在实际开发中,每个服务都需要大量的配置文件,因此就需要有一个统一管理配置文件的组件,spring cloud 的Config组件/阿里的Diamond组件/携程的Apollo组件等等. 这些组件实现的功能大体相同. 以spring cloud Config来阐述一下服务配置统一管理的工作流程:

- config server(配置服务)读取配置文件仓库的信息,仓库可以是本地也可以是远程
- 配置服务启动后,读取的配置文件信息存于内存之中.
- 当其他服务启动需要读取配置信息的时候,向配置服务读取.
- 服务的配置信息修改且修改完成后,发送post请求给配置服务进行刷新,同时其他服务向配置服务重新读取配置



### 服务的链路追踪

服务的链路追踪其实就是记录一个请求从头到尾经过了多少个服务,并且记录先后顺序. 

目前常见的链路追踪组件有Google的Dapper,Twitter的Zipkin以及阿里的Eagleeye(鹰眼)等.








